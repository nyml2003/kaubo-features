# 基于NaN Boxing的64位字类型标记完整实现方法

基于64位IEEE 754双精度浮点数规范（1位符号位S + 11位指数位E + 52位尾数位M），将尾数位M拆分为7位Tag位（M51~M45）+ 45位自定义空间位（M44~M0），形成「1(S)+11(E)+7(Tag)+45(自定义空间)」的完整NaN Boxing架构。该架构既严格兼容IEEE 754原生浮点特殊值的语义，又通过Tag位和45位自定义空间的灵活分配，实现对所有内置类型的极致性能优化，具体分类及规则如下：

## 一、IEEE 754原生浮点特殊值（保留标准位模式，无自定义逻辑）

|类型|符号位(S)|指数位(E)|尾数位(M)|判断逻辑|适用场景|
|---|---|---|---|---|---|
|正浮点0|0|0（全0，0x000）|0（全0）|检测E=0x000且M=0且S=0|原生浮点数值中的正零|
|负浮点0|1|0（全0，0x000）|0（全0）|检测E=0x000且M=0且S=1|原生浮点数值中的负零|
|正无穷大|0|1（全1，0x7FF）|0（全0）|检测E=0x7FF且M=0且S=0|原生浮点数值中的正无穷|
|负无穷大|1|1（全1，0x7FF）|0（全0）|检测E=0x7FF且M=0且S=1|原生浮点数值中的负无穷|

## 二、自定义内置特殊值（非堆类型，纯位运算判断）

此类值基于NaN区域（E=0x7FF且M≠0）实现，无需访问堆内存，仅通过7位Tag即可完成类型判断：

|Tag值|对应类型|45位自定义空间用途|判断逻辑|处理流程|适用场景|
|---|---|---|---|---|---|
|0|语言级真NaN|全0（无实际意义）|提取7位Tag=0且E=0x7FF且M≠0|直接判定为NaN，无后续操作|替代原生NaN，统一语言层NaN语义|
|1|null|全0|提取7位Tag=1且E=0x7FF且M≠0|直接判定为null，无后续操作|原生null值的快速标记与判断|
|2|true|全0|提取7位Tag=2且E=0x7FF且M≠0|直接判定为布尔值true，无后续操作|布尔值true的快速标记与判断|
|3|false|全0|提取7位Tag=3且E=0x7FF且M≠0|直接判定为布尔值false，无后续操作|布尔值false的快速标记与判断|
|4|SMI（小整数）|45位有符号整数|提取7位Tag=4且E=0x7FF|符号扩展后得到44位有符号整数|小范围整数的快速存储，避免堆分配|
|5|预留|全0|提取7位Tag=5且E=0x7FF且M≠0|按预留规则判定|扩展内置特殊值|
|6|预留|全0|提取7位Tag=6且E=0x7FF且M≠0|按预留规则判定|扩展内置特殊值|
|7|预留|全0|提取7位Tag=7且E=0x7FF且M≠0|按预留规则判定|扩展内置特殊值|
|8~23|内联小整数 -8~7|全0|提取7位Tag在8~23区间且E=0x7FF且M≠0|Tag-16 即为整数值 (-8~7)|最高频小整数的零空间存储|
|24~31|预留|全0|提取7位Tag在24~31区间且E=0x7FF且M≠0|按预留规则判定|扩展内置特殊值（如空数组/对象/字符串标记等）|

### SMI（小整数）详细说明

**为什么需要两种整数存储？**

- **内联整数（Tag 8~15）**：-8 到 7 共16个最高频整数，无需 Payload 空间，直接通过 Tag 值判断
- **SMI（Tag 4）**：利用45位 Payload 存储更大范围的整数 (-2^44 ~ 2^44-1)，满足绝大多数整数运算需求

**SMI 的编码与解码**

```
编码：QNAN | (4 << 45) | (value & 0x1FFFFFFFFFFF)
       ↑      ↑ Tag=4      ↑ 45位有符号整数
       └──────┴────────────┘
              7位Tag + 45位Payload = 52位尾数

decode: 
  1. 提取45位: payload = bits & 0x1FFFFFFFFFFF
  2. 符号扩展: if payload & (1 << 44) { payload | (~0 << 45) }
  3. 结果: 有符号44位整数
```

**整数范围对比**

|存储方式|范围|位宽|Tag占用|使用条件|
|---|---|---|---|---|
|内联整数|-8 ~ 7|4位隐含|16个 (8~23)|自动转换，最高频整数|
|SMI|-2^44 ~ 2^44-1 (约±17万亿)|45位|1个 (4)|超出内联范围时|
|堆对象（BigInt）|无限|动态分配|堆类型Tag|超出SMI范围时|

## 三、内置堆类型（Tag编码类型，45位为地址片段）

此类值同样基于NaN区域（E=0x7FF且M≠0）实现，7位Tag编码具体堆类型，45位空间存储地址片段，需转换为48位指针后访问堆对象：

|Tag值|对应类型|45位自定义空间用途|地址转换逻辑|判断流程|适用场景|
|---|---|---|---|---|---|
|32|通用堆对象|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag=32→转换地址→访问对象头获取具体类型|通用对象容器，通过对象头二次分派|
|33|字符串|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag=33→转换地址→直接判定为字符串|字符串对象的快速类型判断与地址访问|
|34|函数|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag=34→转换地址→直接判定为函数|函数对象的快速类型判断与地址访问|
|35|列表|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag=35→转换地址→直接判定为列表|列表对象的快速类型判断与地址访问|
|36|迭代器|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag=36→转换地址→直接判定为迭代器|迭代器对象的快速类型判断与地址访问|
|37|闭包|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag=37→转换地址→直接判定为闭包|闭包对象的快速类型判断与地址访问|
|38~127|预留（Map/Set/Date/Error等）|原始地址片段|掩码0x00000FFFFFFFFFFF提取45位地址→左移3位|提取7位Tag在38~127区间→转换地址→按预留规则判定|扩展内置堆类型|

## 四、类型判断优先级与整体流程

```
判断流程（按优先级从高到低）：

1. 检测 E=0x000 且 M=0
   ├─ S=0 → 正浮点0
   └─ S=1 → 负浮点0

2. 检测 E=0x7FF 且 M=0
   ├─ S=0 → 正无穷大
   └─ S=1 → 负无穷大

3. 检测 E=0x7FF 且 M≠0 → 进入NaN Boxing区域
   └─ 提取7位Tag:
      ├─ Tag=0 → 语言级NaN
      ├─ Tag=1 → null
      ├─ Tag=2 → true
      ├─ Tag=3 → false
      ├─ Tag=4 → SMI（解析45位有符号整数）
      ├─ Tag=5~7 → 预留内联值
      ├─ Tag=8~23 → 内联整数-8~7 (value = Tag-16)
      ├─ Tag=24~31 → 预留内联值
      ├─ Tag=32 → 通用堆对象
      ├─ Tag=33 → 字符串
      ├─ Tag=34 → 函数
      ├─ Tag=35 → 列表
      ├─ Tag=36 → 迭代器
      ├─ Tag=37 → 闭包
      └─ Tag=38~127 → 预留堆类型

4. 以上都不是 → 普通浮点数（IEEE 754标准编码）
```

## 五、核心补充说明

1. **地址转换的核心目的**：45位地址左移3位后得到48位指针，天然适配x86-64架构的48位虚拟地址规则，且低3位恒为0，符合8字节对齐要求，消除CPU非对齐访问的性能损耗；

2. **SMI与内联整数的协同**：
   - 编译期或构造时自动选择最优编码：-8~7用内联，更大范围用SMI
   - 运行时透明：对外暴露统一接口，内部根据Tag自动解码
   - 溢出处理：SMI运算结果超出范围时自动提升为堆对象（BigInt）

3. **整体判断流程优化**：先判定原生浮点特殊值→再判定自定义内联值（包括SMI）→最后判定内置堆类型，全程优先纯位运算；

4. **兼容性**：所有位模式均兼容IEEE 754标准，不会被硬件/编译器误判为普通浮点数，同时完整保留原生浮点特殊值的语义，无功能冲突。

## 六、Rust实现要点

```rust
// 常量定义
const QNAN: u64 = 0x7FF8_0000_0000_0000;        // Quiet NaN: E=0x7FF, 最高位M=1
const TAG_MASK: u64 = 0x7F << 45;                // 7位Tag在bits 51-45
const PAYLOAD_MASK: u64 = 0x1FFFFFFFFFFF;        // 45位Payload

// Tag 定义
const TAG_NAN: u64 = 0 << 45;
const TAG_NULL: u64 = 1 << 45;
const TAG_TRUE: u64 = 2 << 45;
const TAG_FALSE: u64 = 3 << 45;
const TAG_SMI: u64 = 4 << 45;
// Tag 5-7: 预留
const TAG_INLINE_INT_START: u64 = 8 << 45;       // -8
const TAG_INLINE_INT_END: u64 = 23 << 45;        // +7
// Tag 16-31: 预留
const TAG_HEAP_OBJECT: u64 = 32 << 45;
const TAG_STRING: u64 = 33 << 45;
const TAG_FUNCTION: u64 = 34 << 45;
const TAG_LIST: u64 = 35 << 45;
const TAG_ITERATOR: u64 = 36 << 45;
const TAG_CLOSURE: u64 = 37 << 45;
// Tag 38-127: 预留

// 构造SMI
pub fn smi(n: i64) -> Value {
    debug_assert!(n >= -(1 << 44) && n < (1 << 44), "SMI out of range");
    let payload = (n as u64) & PAYLOAD_MASK;
    Value(QNAN | TAG_SMI | payload)
}

// 判断是否为内联整数
pub fn is_inline_int(&self) -> bool {
    let tag = (self.0 & TAG_MASK) >> 45;
    tag >= 8 && tag <= 23
}

// 解包内联整数
pub fn as_inline_int(&self) -> Option<i64> {
    let tag = (self.0 & TAG_MASK) >> 45;
    if tag >= 8 && tag <= 23 {
        Some((tag as i64) - 16)  // 8->-8, 15->-1, 16->0, 23->7
    } else {
        None
    }
}

// 构造内联整数（编译期自动选择）
pub fn int(n: i64) -> Value {
    match n {
        -8..=7 => Value(QNAN | ((n + 16) as u64) << 45),     // 内联: -8->8, 0->16, 7->23
        -(1 << 44)..=(1 << 44) - 1 => Self::smi(n),         // SMI
        _ => Self::bigint(n),                                // 堆对象
    }
}
```

> （注：文档部分内容可能由 AI 生成）
