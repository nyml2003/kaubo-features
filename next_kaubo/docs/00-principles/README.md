# Kaubo 核心原则

> 为个人创作者打造的快速迭代脚本语言

## 愿景

Kaubo 是一个**编译型静态脚本语言**，专为需要**极致迭代效率**的个人创作者设计。

它允许你在代码运行中即时修改、即时生效，无需重启，状态不丢失——就像修改一个正在运转的机器，而不用停机重装。

### 核心用户场景

1. **游戏原型开发** - 调整角色参数立即看到效果，无需重新编译游戏
2. **实时创意编程** - 演出、视觉艺术中的即时反馈
3. **个人工具链** - 快速搭建专用DSL，随需求演化

## 设计原则（不可妥协）

### 1. 迭代速度优先于执行速度

**解释**：程序员的时间是首要资源。等待编译/重启的时间必须最小化。

**具体表现**：
- 热重载必须在1秒内生效
- 错误信息必须精确到可立即定位
- 调试时优先可观测性，而非性能

**例外**：当性能影响用户体验时（如掉帧），允许暂时牺牲迭代速度。

### 2. 个人可控优于生态完整

**解释**：这是个人项目，不需要讨好所有人。作者可以完全掌控设计决策。

**具体表现**：
- 语法可以大胆实验，不追求向后兼容
- 可以为了简洁砍掉"应该有的"功能

**例外**：如果某个功能成为作者自己的痛点，必须解决。

### 3. 架构预留优于当下实现

**解释**：当前不做的功能，不能通过硬编码假设堵死未来。避免后续大规模重构。

**具体表现**：
- 平台相关代码隔离在最小范围内（即使当前只支持Windows）
- 字节码/内存布局预留版本号或扩展字段
- 模块边界清晰，允许内部重写而不影响外部

**为什么**：个人项目会随时间演化，今天的"确定不做"可能是明天的"突然发现需要"。架构锁定比重构成本更高。

**例外**：当预留扩展点显著增加当前复杂度（>20%）时，允许暂时硬编码。

### 4. 实现简洁优于理论完美

**解释**：代码是负债，不是资产。能工作的简单方案胜过完美的复杂方案。

**具体表现**：
- 不做完整的类型系统，做够用的类型检查
- 不做工业级GC，做满足场景的内存管理
- 不做通用优化，做场景特化优化

**例外**：当简洁导致反复踩同一个坑时，考虑增加复杂度。

### 5. 流式体验优于批处理

**解释**：创作者应该看到即时的、连续的反馈，而非离散的阶段。

**具体表现**：
- 输入代码时就有语法高亮和错误提示
- 保存时立即触发增量编译
- 运行时修改立即热重载

**例外**：当流式处理引入不可接受的延迟时，允许批处理。

### 6. 结构化接口优于环境依赖

**解释**：系统行为必须通过显式的、类型安全的API控制，而非隐式的环境状态（环境变量、全局配置、编译期开关）。

**具体表现**：
- CLI、嵌入、测试等不同入口使用同一套配置结构
- 日志级别、功能开关通过代码传递，而非`#[cfg]`或`env::var`
- 性能可以牺牲，接口一致性必须保证

**例外**：当结构化接口引入无法接受的性能开销（如>50% slowdown）时，允许编译期特化。

**为什么**：个人项目需要在不同场景（交互式CLI、游戏嵌入、自动化测试）下灵活使用，环境依赖会导致行为不可预测。

### 7. 文档先行优于代码先行

**解释**：设计必须在代码之前成型，架构必须在实现之前被记录。个人项目容易陷入"先写再看"的陷阱，导致回头补文档时设计已劣化。

**具体表现**：
- 新增模块前先有文档（接口、数据结构、使用示例）
- 复杂功能先有设计文档（方案对比、决策理由）
- 文档即契约：代码必须符合文档，文档优先于实现细节

**例外**：纯探索性原型（<100行）可先行验证，验证后立即补文档或废弃。

**为什么**：写文档是思考设计的过程，个人项目没有代码审查，文档即自我审查。

### 8. 显式命名优于隐式约定

**解释**：代码中的命名应该清晰明确，禁止通过前缀 `_` 来表示"未使用"。这是为 AI 生成代码设定的硬性规范。

**具体表现**：
- **禁止使用 `_` 开头的变量名**（如 `_temp`, `_unused`）
- 如需忽略未使用变量，显式使用 `drop()` 或添加 `#[allow(unused)]`
- 函数/变量命名直接表达用途，不依赖上下文推断

**为什么**：
- AI 容易误用 `_` 前缀产生歧义
- `_` 前缀在 Rust 中表示"故意不使用"，但这种隐式约定不利于代码审查
- 显式命名减少维护时的理解成本

**正确示例**：
```rust
// ✅ 正确
let temp = calculate_value();
drop(temp); // 显式标记不使用

#[allow(unused)]
let unused_variable = 42;

// ❌ 错误
let _temp = 42;
let _unused = "hello";
```

### 9. 日志优先优于猜测调试

**解释**：当系统出现意外行为时，第一反应应该是查看日志，而不是凭空猜测或盲目修改代码。完善的日志是系统的"黑匣子"，能准确告诉你发生了什么。

**具体表现**：
- 核心组件必须记录关键决策点（如类型推导、运算符分发、字段索引）
- 错误信息必须包含上下文（如 `Field index 0 (x)` 而非 `Index error`）
- 调试时先用 `-vv` 看日志，再考虑加 `println!` 或断点
- 测试失败时，检查测试输出中的日志是否足够定位问题

**例外**：性能敏感路径（如内层循环）可以省略日志，但必须在文档中说明。

**补充**：如果现有日志无法定位问题，**优先补充日志代码**，而非继续猜测或加断点。新增的日志应该回答"数据从哪来、到哪去、经过哪些转换"。

**日志补充方法**：
1. **在哪加**：
   - 函数入口：记录参数值
   - 分支决策点：记录选择哪个分支及原因
   - 数据转换处：记录转换前后的值
   - 返回值前：记录最终结果

2. **加什么**：
   - 使用 `debug!` 或 `trace!` 级别（不污染正常输出）
   - 包含变量名和值，如 `trace!(logger, "fields = {:?}", fields)`
   - 对复杂结构，打印关键字段而非整个结构

3. **示例**：
   ```rust
   // 在 call_operator_closure 的 BuildStruct 处理中添加
   trace!(logger, "BuildStruct: popping {} fields", field_count);
   for i in 0..field_count {
       let val = self.pop();
       trace!(logger, "  field[{}] = {:?}", i, val);
       fields.push(val);
   }
   trace!(logger, "BuildStruct: final fields = {:?}", fields);
   ```

**为什么**：
- 猜测调试浪费时间，且容易引入新 bug
- 日志是事实，猜测是假设
- 个人项目没有团队协作，日志就是最好的"同事"

**示例**：
```rust
// ❌ 错误：出现问题先猜
// "v3.x 和 v3.y 打印反了？可能是 GetField 索引算错了..."
// 于是去改字段索引计算，结果越改越乱

// ✅ 正确：先开日志看发生了什么
cargo run -- -vv examples/hello.kaubo
// 日志显示：BuildStruct fields=[y: 4.0, x: 6.0] 
// 啊！是 call_operator_closure 里多调了 reverse()
```

## 成功标准

Kaubo 成功，当且仅当：

- 作者愿意用它写自己的 side project
- 修改一行代码到看到效果 < 1秒
- 热重载不丢失运行状态
- 语法演进时，旧代码迁移成本 < 10分钟

## 非目标（明确不做）

- 成为通用编程语言
- 支持多平台（至少初期不追求）
- 大规模团队协作
- 企业级稳定性保证
- 与现有生态（npm/cargo等）集成

---

*最后更新：2026-02-14*  
*新增原则7：文档先行优于代码先行*  
*新增原则8：显式命名优于隐式约定*
*新增原则9：日志优先优于猜测调试*
*状态：稳定（这些原则改变意味着项目本质改变）*
