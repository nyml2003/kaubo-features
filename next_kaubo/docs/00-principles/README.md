# Kaubo 核心原则

> 为个人创作者打造的快速迭代脚本语言

## 愿景

Kaubo 是一个**编译型静态脚本语言**，专为需要**极致迭代效率**的个人创作者设计。

它允许你在代码运行中即时修改、即时生效，无需重启，状态不丢失——就像修改一个正在运转的机器，而不用停机重装。

### 核心用户场景

1. **游戏原型开发** - 调整角色参数立即看到效果，无需重新编译游戏
2. **实时创意编程** - 演出、视觉艺术中的即时反馈
3. **个人工具链** - 快速搭建专用DSL，随需求演化

## 设计原则（不可妥协）

### 1. 迭代速度优先于执行速度

**解释**：程序员的时间是首要资源。等待编译/重启的时间必须最小化。

**具体表现**：
- 热重载必须在1秒内生效
- 错误信息必须精确到可立即定位
- 调试时优先可观测性，而非性能

**例外**：当性能影响用户体验时（如掉帧），允许暂时牺牲迭代速度。

### 2. 个人可控优于生态完整

**解释**：这是个人项目，不需要讨好所有人。作者可以完全掌控设计决策。

**具体表现**：
- 语法可以大胆实验，不追求向后兼容
- 可以为了简洁砍掉"应该有的"功能

**例外**：如果某个功能成为作者自己的痛点，必须解决。

### 3. 架构预留优于当下实现

**解释**：当前不做的功能，不能通过硬编码假设堵死未来。避免后续大规模重构。

**具体表现**：
- 平台相关代码隔离在最小范围内（即使当前只支持Windows）
- 字节码/内存布局预留版本号或扩展字段
- 模块边界清晰，允许内部重写而不影响外部

**为什么**：个人项目会随时间演化，今天的"确定不做"可能是明天的"突然发现需要"。架构锁定比重构成本更高。

**例外**：当预留扩展点显著增加当前复杂度（>20%）时，允许暂时硬编码。

### 4. 实现简洁优于理论完美

**解释**：代码是负债，不是资产。能工作的简单方案胜过完美的复杂方案。

**具体表现**：
- 不做完整的类型系统，做够用的类型检查
- 不做工业级GC，做满足场景的内存管理
- 不做通用优化，做场景特化优化

**例外**：当简洁导致反复踩同一个坑时，考虑增加复杂度。

### 5. 流式体验优于批处理

**解释**：创作者应该看到即时的、连续的反馈，而非离散的阶段。

**具体表现**：
- 输入代码时就有语法高亮和错误提示
- 保存时立即触发增量编译
- 运行时修改立即热重载

**例外**：当流式处理引入不可接受的延迟时，允许批处理。

### 6. 结构化接口优于环境依赖

**解释**：系统行为必须通过显式的、类型安全的API控制，而非隐式的环境状态（环境变量、全局配置、编译期开关）。

**具体表现**：
- CLI、嵌入、测试等不同入口使用同一套配置结构
- 日志级别、功能开关通过代码传递，而非`#[cfg]`或`env::var`
- 性能可以牺牲，接口一致性必须保证

**例外**：当结构化接口引入无法接受的性能开销（如>50% slowdown）时，允许编译期特化。

**为什么**：个人项目需要在不同场景（交互式CLI、游戏嵌入、自动化测试）下灵活使用，环境依赖会导致行为不可预测。

### 7. 文档先行优于代码先行

**解释**：设计必须在代码之前成型，架构必须在实现之前被记录。个人项目容易陷入"先写再看"的陷阱，导致回头补文档时设计已劣化。

**具体表现**：
- 新增模块前先有文档（接口、数据结构、使用示例）
- 复杂功能先有设计文档（方案对比、决策理由）
- 文档即契约：代码必须符合文档，文档优先于实现细节

**例外**：纯探索性原型（<100行）可先行验证，验证后立即补文档或废弃。

**为什么**：写文档是思考设计的过程，个人项目没有代码审查，文档即自我审查。

### 8. 显式命名优于隐式约定

**解释**：代码中的命名应该清晰明确，禁止通过前缀 `_` 来表示"未使用"。这是为 AI 生成代码设定的硬性规范。

**具体表现**：
- **禁止使用 `_` 开头的变量名**（如 `_temp`, `_unused`）
- 如需忽略未使用变量，显式使用 `drop()` 或添加 `#[allow(unused)]`
- 函数/变量命名直接表达用途，不依赖上下文推断

**为什么**：
- AI 容易误用 `_` 前缀产生歧义
- `_` 前缀在 Rust 中表示"故意不使用"，但这种隐式约定不利于代码审查
- 显式命名减少维护时的理解成本

**正确示例**：
```rust
// ✅ 正确
let temp = calculate_value();
drop(temp); // 显式标记不使用

#[allow(unused)]
let unused_variable = 42;

// ❌ 错误
let _temp = 42;
let _unused = "hello";
```

## 成功标准

Kaubo 成功，当且仅当：

- 作者愿意用它写自己的 side project
- 修改一行代码到看到效果 < 1秒
- 热重载不丢失运行状态
- 语法演进时，旧代码迁移成本 < 10分钟

## 非目标（明确不做）

- 成为通用编程语言
- 支持多平台（至少初期不追求）
- 大规模团队协作
- 企业级稳定性保证
- 与现有生态（npm/cargo等）集成

---

*最后更新：2026-02-14*  
*新增原则7：文档先行优于代码先行*  
*新增原则8：显式命名优于隐式约定*
*状态：稳定（这些原则改变意味着项目本质改变）*
