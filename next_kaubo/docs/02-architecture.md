# Kaubo é¡¹ç›®æ¶æ„

> æ•´ä½“æ¶æ„ã€æ ¸å¿ƒç»„ä»¶ã€æ—¥å¿—ç³»ç»Ÿä¸é…ç½®ç®¡ç†

## ç›®å½•

1. [æ•´ä½“æ¶æ„](#1-æ•´ä½“æ¶æ„)
2. [åˆ†å±‚è®¾è®¡](#2-åˆ†å±‚è®¾è®¡)
3. [æ—¥å¿—ç³»ç»Ÿ](#3-æ—¥å¿—ç³»ç»Ÿ)
4. [é…ç½®ç®¡ç†](#4-é…ç½®ç®¡ç†)
5. [æ ¸å¿ƒç»„ä»¶](#5-æ ¸å¿ƒç»„ä»¶)
6. [å†…å­˜å¸ƒå±€](#6-å†…å­˜å¸ƒå±€)
7. [æ–‡ä»¶ç»“æ„](#7-æ–‡ä»¶ç»“æ„)

---

## 1. æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨å±‚ (Application)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚    CLI       â”‚  â”‚   é™æ€åº“API   â”‚  â”‚   æµ‹è¯•æ¡†æ¶    â”‚      â”‚
â”‚  â”‚  (main.rs)   â”‚  â”‚  (lib.rs)    â”‚  â”‚  (tests/)    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                 â”‚                 â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç¼–æ’å±‚ (Orchestration)                   â”‚
â”‚                        src/api.rs                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  pub fn compile_and_run(source: &str) -> Result<...>  â”‚  â”‚
â”‚  â”‚  pub fn compile(source: &str) -> Result<...>          â”‚  â”‚
â”‚  â”‚  pub fn execute(chunk: &Chunk) -> Result<...>         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç¼–è¯‘é˜¶æ®µ     â”‚  â”‚   æ‰§è¡Œé˜¶æ®µ     â”‚  â”‚   åŸºç¡€è®¾æ–½     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Lexer       â”‚  â”‚ â€¢ VM          â”‚  â”‚ â€¢ Config      â”‚
â”‚ â€¢ Parser      â”‚  â”‚ â€¢ Memory      â”‚  â”‚ â€¢ Logger      â”‚
â”‚ â€¢ Compiler    â”‚  â”‚ â€¢ Stdlib      â”‚  â”‚ â€¢ Error       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. åˆ†å±‚è®¾è®¡

### 2.1 API åˆ†å±‚

| å±‚çº§ | æ¨¡å— | èŒè´£ | ä½¿ç”¨åœºæ™¯ |
|------|------|------|---------|
| **åº”ç”¨å±‚** | `main.rs` | CLI å‚æ•°è§£æã€æµç¨‹è°ƒåº¦ | å‘½ä»¤è¡Œå·¥å…· |
| **ç¼–æ’å±‚** | `api.rs` | é˜¶æ®µç»„åˆã€é”™è¯¯å¤„ç† | åº“ç”¨æˆ·ã€æµ‹è¯• |
| **é˜¶æ®µå±‚** | `lexer/parser/compiler/vm` | ç‹¬ç«‹åŠŸèƒ½å®ç° | å•ç‹¬è°ƒç”¨ã€è°ƒè¯• |
| **åŸºç¡€è®¾æ–½** | `config/logger` | å…¨å±€é…ç½®ã€æ—¥å¿— | è´¯ç©¿æ‰€æœ‰å±‚ |

### 2.2 è°ƒç”¨ç¤ºä¾‹

```rust
// åº”ç”¨å±‚ (CLI)
fn main() {
    let cli = Cli::parse();
    kaubo::config::init(build_config(&cli));
    kaubo::logger::init();
    
    let result = kaubo::compile_and_run(&source)?;
    println!("{}", result.value);
}

// ç¼–æ’å±‚ (API)
pub fn compile_and_run(source: &str) -> Result<ExecuteOutput> {
    let tokens = lex(source)?;      // é˜¶æ®µ1
    let ast = parse(&tokens)?;       // é˜¶æ®µ2
    let compiled = compile(&ast)?;   // é˜¶æ®µ3
    execute(&compiled)               // é˜¶æ®µ4
}

// é˜¶æ®µå±‚ (ç‹¬ç«‹ä½¿ç”¨)
let tokens = kaubo::lex(source)?;
```

---

## 3. æ—¥å¿—ç³»ç»Ÿ

### 3.1 è®¾è®¡ç›®æ ‡

- **åˆ†é˜¶æ®µæ§åˆ¶**: å¯ç‹¬ç«‹æ§åˆ¶ lexer/parser/compiler/vm çš„æ—¥å¿—çº§åˆ«
- **ç»“æ„åŒ–è¾“å‡º**: æ”¯æŒ JSON æ ¼å¼ä¾›å·¥å…·è§£æ
- **ä½å¼€é”€**: æœªå¯ç”¨çš„æ—¥å¿—åœ¨ç¼–è¯‘æœŸä¼˜åŒ–æ‰
- **è·¨åº¦è¿½è¸ª**: æ”¯æŒåµŒå¥—è°ƒç”¨é“¾è¿½è¸ª

### 3.2 æ—¥å¿—åˆ†çº§

| çº§åˆ« | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| `TRACE` | æœ€è¯¦ç»†ï¼Œé€è¡Œè°ƒè¯• | æ¯ä¸ªå­—ç¬¦å¤„ç†ã€æ¯æ¡æŒ‡ä»¤æ‰§è¡Œ |
| `DEBUG` | å¼€å‘è°ƒè¯• | Tokenç”Ÿæˆã€ASTèŠ‚ç‚¹ã€å‡½æ•°è°ƒç”¨ |
| `INFO` | æ­£å¸¸æµç¨‹ä¿¡æ¯ | é˜¶æ®µå¼€å§‹/å®Œæˆã€ç¼–è¯‘æˆåŠŸ |
| `WARN` | è­¦å‘Š | ä¸å»ºè®®çš„ç”¨æ³•ã€æ€§èƒ½é—®é¢˜ |
| `ERROR` | é”™è¯¯ | ç¼–è¯‘é”™è¯¯ã€è¿è¡Œæ—¶é”™è¯¯ |

### 3.3 é˜¶æ®µè¿‡æ»¤

```rust
// åªæŸ¥çœ‹ Parser çš„ DEBUG ä»¥ä¸Šæ—¥å¿—
$ kaubo script.kaubo --log-parser=debug

// æŸ¥çœ‹å…¨éƒ¨ TRACEï¼Œä½† VM åªæ˜¾ç¤º INFO
$ kaubo script.kaubo -vvv --log-vm=info
```

### 3.4 æ—¥å¿—æ ¼å¼

**Pretty æ ¼å¼**ï¼ˆå¼€å‘ä½¿ç”¨ï¼‰:
```
2024-02-10T10:23:45.123Z DEBUG kaubo::parser: parse variable_declaration
2024-02-10T10:23:45.124Z DEBUG kaubo::compiler: compile binary_op Add
2024-02-10T10:23:45.125Z TRACE kaubo::vm: op=LoadConst0 stack=[]
2024-02-10T10:23:45.126Z TRACE kaubo::vm: op=LoadConst1 stack=[SMI(1)]
```

**JSON æ ¼å¼**ï¼ˆå·¥å…·é›†æˆï¼‰:
```json
{
  "timestamp": "2024-02-10T10:23:45.123Z",
  "level": "DEBUG",
  "target": "kaubo::parser",
  "fields": {
    "message": "parse variable_declaration",
    "line": 10
  }
}
```

### 3.5 ä»£ç ä¸­ä½¿ç”¨

```rust
use tracing::{debug, error, info, instrument, trace, warn};

// ç®€å•æ—¥å¿—
debug!("Processing {} tokens", count);

// ç»“æ„åŒ–æ—¥å¿—
debug!(token.kind = ?kind, token.value = %value, "Produced token");

// å‡½æ•°çº§è·¨åº¦ï¼ˆè‡ªåŠ¨è®°å½•è¿›å…¥/é€€å‡ºï¼‰
#[instrument(target = "kaubo::lexer", skip(source))]
pub fn lex(source: &str) -> Result<Vec<Token>> {
    info!("Starting lexer");
    // ...
}

// æ¡ä»¶æ—¥å¿—
if tracing::enabled!(tracing::Level::TRACE) {
    trace!("Expensive debug: {:?}", expensive_operation());
}
```

---

## 4. é…ç½®ç®¡ç†

### 4.1 å…¨å±€é…ç½®å•ä¾‹

```rust
// src/config.rs
use once_cell::sync::OnceCell;

static GLOBAL_CONFIG: OnceCell<Config> = OnceCell::new();

pub fn init(config: Config) {
    GLOBAL_CONFIG.set(config).ok();
}

pub fn config() -> &'static Config {
    GLOBAL_CONFIG.get().expect("Config not initialized")
}
```

### 4.2 é…ç½®ç»“æ„

```rust
pub struct Config {
    /// æ—¥å¿—é…ç½®
    pub log: LogConfig,
    /// æ‰§è¡Œé™åˆ¶
    pub limits: LimitConfig,
    /// ç¼–è¯‘é€‰é¡¹
    pub compiler: CompilerConfig,
}

pub struct LogConfig {
    pub global: Level,           // é»˜è®¤çº§åˆ«
    pub lexer: Option<Level>,    // None = ä½¿ç”¨ global
    pub parser: Option<Level>,
    pub compiler: Option<Level>,
    pub vm: Option<Level>,
}

pub struct LimitConfig {
    pub max_stack_size: usize,      // é»˜è®¤ 1024
    pub max_recursion_depth: usize, // é»˜è®¤ 256
}

pub struct CompilerConfig {
    pub emit_debug_info: bool,  // æ˜¯å¦ç”Ÿæˆè°ƒè¯•ä¿¡æ¯
}
```

### 4.3 CLI é…ç½®æ˜ å°„

```bash
# åŸºç¡€çº§åˆ«
kaubo script.kaubo              # WARN (é»˜è®¤)
kaubo script.kaubo -v           # INFO
kaubo script.kaubo -vv          # DEBUG
kaubo script.kaubo -vvv         # TRACE

# é˜¶æ®µçº§æ§åˆ¶
kaubo script.kaubo --log-lexer=trace
kaubo script.kaubo --log-parser=off --log-vm=debug
```

---

## 5. ç¼–è¯‘å™¨å‰ç«¯æ¶æ„ (Lexer â†’ Parser â†’ AST)

### 5.0 æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Compiler Frontend                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Source â”€â”€â–º Lexer â”€â”€â–º Token Stream â”€â”€â–º Parser â”€â”€â–º AST            â”‚
â”‚   Text      (LAYER 1)   (Interface)    (LAYER 2)   (Tree)        â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚CharStreamâ”‚      â”‚  Token   â”‚      â”‚  Recursive Descent   â”‚   â”‚
â”‚  â”‚Scanner   â”‚â”€â”€â”€â”€â”€â–ºâ”‚  (Kind+  â”‚â”€â”€â”€â”€â”€â–ºâ”‚  + Pratt Parser      â”‚   â”‚
â”‚  â”‚(Mode)    â”‚      â”‚  Span)   â”‚      â”‚                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚       â”‚
â”‚                                                          â–¼       â”‚
â”‚                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                               â”‚  Expr/Stmt/Module â”‚
â”‚                                               â”‚  (AST Nodes)      â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆæ–¹æ¡ˆä¸»è¦å…³æ³¨ Lexerï¼Ÿ**

Lexer æ˜¯æ•´ä¸ªç¼–è¯‘å™¨çš„åŸºç¡€å±‚ï¼Œå…¶è®¾è®¡è´¨é‡ç›´æ¥å½±å“ Parserã€LSPã€IDE ç­‰ä¸Šå±‚åŠŸèƒ½ã€‚å½“å‰çš„å¤šçŠ¶æ€æœºæ¶æ„å­˜åœ¨æ‰©å±•æ€§å·®ã€æ€§èƒ½ä½ã€ç»´æŠ¤æˆæœ¬é«˜ç­‰é—®é¢˜ï¼Œå¿…é¡»å…ˆè§£å†³ã€‚Parser é‡‡ç”¨ç»å…¸çš„é€’å½’ä¸‹é™ + Pratt è¡¨è¾¾å¼è§£æï¼Œæ¶æ„å¥åº·ï¼Œæ— éœ€å¤§è§„æ¨¡æ”¹é€ ï¼Œåªéœ€é€‚é…æ–°çš„ Lexer æ¥å£ã€‚

---

### 5.1 è¯æ³•åˆ†æå™¨ (Lexer)

**çŠ¶æ€**: âœ… å·²å®Œæˆæ‰‹å†™ Scanner æ”¹é€ ï¼ˆåŸå¤šçŠ¶æ€æœºå·²ç§»é™¤ï¼‰  
**ä½ç½®**: `src/kit/lexer/`  
**æ—¥å¿—ç›®æ ‡**: `kaubo::lexer`

#### æ–‡ä»¶ç»“æ„

```
src/kit/lexer/
â”œâ”€â”€ mod.rs              # æ¨¡å—å¯¼å‡º
â”œâ”€â”€ types.rs            # Coordinateï¼ˆä¾› Parser ä½¿ç”¨ï¼‰
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ position.rs     # SourcePosition + SourceSpan
â”‚   â””â”€â”€ stream.rs       # CharStreamï¼ˆå­—ç¬¦æµæŠ½è±¡ï¼‰
â”œâ”€â”€ scanner.rs          # Scanner trait + Token ç»“æ„
â”œâ”€â”€ kaubo.rs            # KauboScanner å®ç°
â””â”€â”€ lexer.rs            # Lexer å…¥å£
```

#### 5.1.1 ä¸‰å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LAYER 3: Language Frontends                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚ Kaubo   â”‚ â”‚  JSON   â”‚ â”‚Vue/HTML â”‚   å£°æ˜å¼è¯­æ³•å®šä¹‰            â”‚
â”‚  â”‚         â”‚ â”‚         â”‚ â”‚Template â”‚   å¿«é€Ÿè¯­æ³•è¿­ä»£              â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       â”‚           â”‚           â”‚        LAYER 2: Core            â”‚
â”‚       â–¼           â–¼           â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Universal Scanner Engine                    â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚ Scanner  â”‚ â”‚ Token    â”‚ â”‚ Error    â”‚ â”‚ Mode     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚ Trait    â”‚ â”‚ Builder  â”‚ â”‚ Recovery â”‚ â”‚ System   â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  LAYER 1: Infrastructure                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚CharStreamâ”‚ â”‚Position  â”‚ â”‚ RingBuf  â”‚ â”‚Encoding  â”‚           â”‚
â”‚  â”‚(UTF-8/16)â”‚ â”‚Tracker   â”‚ â”‚(æµå¼)    â”‚ â”‚(BOM/CRLF)â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 5.1.2 Lexer-Parser æ¥å£å¥‘çº¦

```rust
/// Token ç»“æ„ï¼ˆParser æ¶ˆè´¹çš„æœ€å°å•å…ƒï¼‰
pub struct Token<K> {
    pub kind: K,                    // Token ç±»å‹
    pub span: Span,                 // æºä»£ç ä½ç½®
    pub text: Option<String>,       // åŸå§‹æ–‡æœ¬ï¼ˆå¯é€‰ï¼ŒèŠ‚çœå†…å­˜ï¼‰
}

/// Span æ”¯æŒå¤šåæ ‡ç³»ç»Ÿï¼ˆä¸º LSP é¢„ç•™ï¼‰
pub struct Span {
    pub start: Position,
    pub end: Position,
}

pub struct Position {
    pub line: usize,                // 1-basedï¼Œè¡Œå·ï¼ˆäººç±»å¯è¯»ï¼‰
    pub column: usize,              // 1-basedï¼Œåˆ—å·ï¼ˆå­—ç¬¦è®¡æ•°ï¼Œæ˜¾ç¤ºç”¨ï¼‰
    pub byte_offset: usize,         // 0-basedï¼Œæ–‡ä»¶å­—èŠ‚åç§»ï¼ˆUTF-8ï¼Œæ–‡ä»¶seekç”¨ï¼‰
    pub utf16_column: usize,        // 0-basedï¼Œè¡Œå†…UTF-16åç§»ï¼ˆLSP Position.characterï¼‰
}

**å­—æ®µè¯´æ˜**ï¼ˆä»¥ `var x = "ğŸ‰";` ä¸­å­—ç¬¦ `x` çš„ä½ç½®ä¸ºä¾‹ï¼‰ï¼š

| å­—æ®µ | å€¼ | ç”¨é€” | è¯´æ˜ |
|------|-----|------|------|
| `line` | `1` | é”™è¯¯æ˜¾ç¤º | 1-basedè¡Œå·ï¼Œäººç±»å¯è¯» |
| `column` | `5` | é”™è¯¯æ˜¾ç¤º | 1-basedåˆ—å·ï¼Œè·³è¿‡`var `4ä¸ªå­—ç¬¦ |
| `byte_offset` | `4` | æ–‡ä»¶è·³è½¬ | 0-basedå­—èŠ‚åç§»ï¼Œç”¨äº`seek()` |
| `utf16_column` | `4` | LSPé€šä¿¡ | 0-basedè¡Œå†…åç§»ï¼Œå¯¹åº”LSPçš„`character`å­—æ®µ |

**æ³¨æ„**ï¼š`column`ä¸`utf16_column`çš„åŒºåˆ«ï¼š
- `column`ç”¨äº**æ˜¾ç¤º**ï¼ˆé”™è¯¯ä¿¡æ¯ã€IDEçŠ¶æ€æ ï¼‰ï¼Œæ˜¯1-based
- `utf16_column`ç”¨äº**åè®®é€šä¿¡**ï¼ˆLSPï¼‰ï¼Œæ˜¯0-basedè¡Œå†…åç§»ï¼Œä¸”è®¡ç®—UTF-16å•å…ƒæ•°ï¼ˆä»£ç†å¯¹ç®—2ä¸ªï¼‰

/// Lexer æ¥å£ï¼ˆParser åªä¾èµ–æ­¤ traitï¼‰
pub trait TokenStream<K> {
    fn next_token(&mut self) -> Option<Token<K>>;
    fn peek_token(&self, offset: usize) -> Option<&Token<K>>;
    fn current_position(&self) -> Position;
}
```

#### 5.1.3 å£°æ˜å¼è¯­æ³•å®šä¹‰ï¼ˆå¿«é€Ÿè¯­æ³•è¿­ä»£ï¼‰

```rust
// src/compiler/lexer/kaubo_def.rs
// æ”¹è¯­æ³•åªéœ€ä¿®æ”¹æ­¤æ–‡ä»¶

lexer_definition! {
    name: Kaubo,
    
    keywords: {
        "var" => Var,
        "if" => If,
        "else" => Else,
        "json" => Json,          // DSL å…¥å£ç‚¹
        "xml" => Xml,            // æœªæ¥æ‰©å±•
    },
    
    operators: {
        "==" => EqEq,            // è‡ªåŠ¨æœ€å¤§åŒ¹é…
        "!=" => NotEq,
        "<=" => Le,
        "+" => Plus,             // å•å­—ç¬¦è‡ªåŠ¨å¤„ç†
    },
    
    literals: {
        string: { quotes: ['"', "'"], escape: true },
        integer: { base: [Decimal, Hex] },
    },
    
    comments: {
        line: "//",
        block: ("/*", "*/"),
    },
}
```

#### 5.1.4 æµå¼ä¸å¢é‡æ”¯æŒ

```rust
/// æµå¼è§£æçŠ¶æ€
pub enum StreamResult<T> {
    Token(T),           // æˆåŠŸç”Ÿæˆ Token
    Incomplete,         // éœ€è¦æ›´å¤šè¾“å…¥ï¼ˆæµå¼åœºæ™¯ï¼‰
    Error(LexError),    // è¯æ³•é”™è¯¯
    Eof,
}

/// å¢é‡è§£ææ”¯æŒï¼ˆIDE å®æ—¶åé¦ˆï¼‰
pub struct IncrementalLexer {
    snapshots: Vec<LexerSnapshot>,
    token_cache: LruCache<ContentHash, Vec<Token>>,
}

impl IncrementalLexer {
    /// ç¼–è¾‘åå±€éƒ¨é‡è§£æ
    pub fn on_edit(&mut self, edit: TextEdit) -> Vec<LexError> {
        // 1. æ‰¾åˆ°å—å½±å“çš„ token èŒƒå›´
        // 2. åªé‡æ–°æ‰«æè¿™æ®µ
        // 3. å¦‚æœè¾¹ç•Œ token ç±»å‹ä¸å˜ï¼Œåœæ­¢ä¼ æ’­
        // 4. æ›´æ–°ç¼“å­˜
    }
}
```

#### 5.1.5 å®ç°çŠ¶æ€

| é˜¶æ®µ | çŠ¶æ€ | å®Œæˆæƒ…å†µ |
|------|------|----------|
| Phase 0 | âœ… å®Œæˆ | æ‰‹å†™ Scanner æ›¿æ¢çŠ¶æ€æœºï¼Œ217 æµ‹è¯•é€šè¿‡ï¼ŒO(n) å¤æ‚åº¦ |
| Phase 1 | ğŸš§ å¾…å¼€å§‹ | SourceSpan é›†æˆåˆ°é”™è¯¯ç³»ç»Ÿ |
| Phase 2 | ğŸ“‹ è®¡åˆ’ä¸­ | å¢é‡è§£ææ”¯æŒï¼ˆREPL å®æ—¶åé¦ˆï¼‰ |
| Phase 3 | ğŸ“‹ è§„åˆ’ä¸­ | JSON/Vue Scanner å¤ç”¨ Core å±‚ |

**å…³é”®å˜æ›´**:
- Token ç»“æ„: `coordinate: Coordinate` â†’ `span: SourceSpan`
- Token æ–‡æœ¬: `value: String` â†’ `text: Option<String>`
- Parser è®¿é—®: `token.coordinate.line` â†’ `token.span.start.line`
- å·²ç§»é™¤: `state_machine/` ç›®å½•ã€`c_lexer.rs`ï¼ˆæ—§å®ç°ï¼‰

---

### 5.2 è¯­æ³•åˆ†æå™¨ (Parser)

**å½“å‰çŠ¶æ€**: é€’å½’ä¸‹é™ + Pratt è¡¨è¾¾å¼è§£æï¼ˆæ¶æ„å¥åº·ï¼Œä¿ç•™ï¼‰  
**ä½ç½®**: `src/compiler/parser/`  
**æ—¥å¿—ç›®æ ‡**: `kaubo::parser`

#### 5.2.1 æ¶æ„è®¾è®¡

Parser é‡‡ç”¨ç»å…¸çš„ä¸¤å±‚æ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Parser                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  Pratt Parser (è¡¨è¾¾å¼)                    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚   parse_expression(min_precedence)                       â”‚   â”‚
â”‚  â”‚     â”œâ”€â”€ parse_unary()                                    â”‚   â”‚
â”‚  â”‚     â”‚     â””â”€â”€ parse_primary()                            â”‚   â”‚
â”‚  â”‚     â””â”€â”€ while (current.precedence > min)                 â”‚   â”‚
â”‚  â”‚           â”œâ”€â”€ consume operator                           â”‚   â”‚
â”‚  â”‚           â””â”€â”€ parse_expression(current.precedence)       â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚               Recursive Descent (è¯­å¥)                    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚   parse_statement()                                      â”‚   â”‚
â”‚  â”‚     â”œâ”€â”€ parse_var_declaration()                          â”‚   â”‚
â”‚  â”‚     â”œâ”€â”€ parse_if_statement()                             â”‚   â”‚
â”‚  â”‚     â”œâ”€â”€ parse_while_loop()                               â”‚   â”‚
â”‚  â”‚     â”œâ”€â”€ parse_for_loop()                                 â”‚   â”‚
â”‚  â”‚     â””â”€â”€ parse_expression_statement()                     â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Token Stream Interface                       â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚   check(kind)        - æ£€æŸ¥å½“å‰ token                    â”‚   â”‚
â”‚  â”‚   match_token(kind)  - åŒ¹é…å¹¶æ¶ˆè´¹                        â”‚   â”‚
â”‚  â”‚   expect(kind)       - æœŸæœ›å¹¶æ¶ˆè´¹ï¼Œå¦åˆ™æŠ¥é”™              â”‚   â”‚
â”‚  â”‚   consume()          - æ¶ˆè´¹å½“å‰ token                    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 5.2.2 ä¸ Lexer çš„åä½œ

Parser é€šè¿‡ `TokenStream` trait ä¸ Lexer è§£è€¦ï¼š

```rust
pub struct Parser<K> {
    lexer: Box<dyn TokenStream<K>>,
    current: Option<Token<K>>,
    peeked: Vec<Token<K>>,  // é¢„è¯»ç¼“å†²åŒºï¼ˆç”¨äº lookaheadï¼‰
}

impl<K: TokenKind> Parser<K> {
    /// æ¶ˆè´¹å½“å‰ tokenï¼Œè¯»å–ä¸‹ä¸€ä¸ª
    fn consume(&mut self) {
        self.current = self.lexer.next_token();
    }
    
    /// æ£€æŸ¥å½“å‰ token ç±»å‹
    fn check(&self, kind: K) -> bool {
        self.current.as_ref().map(|t| t.kind == kind).unwrap_or(false)
    }
    
    /// åŒ¹é…å¹¶æ¶ˆè´¹
    fn match_token(&mut self, kind: K) -> bool {
        if self.check(kind) { self.consume(); true } else { false }
    }
    
    /// æœŸæœ›ç‰¹å®š tokenï¼Œå¦åˆ™æŠ¥é”™
    fn expect(&mut self, kind: K) -> ParseResult<()> {
        if self.match_token(kind) { 
            Ok(()) 
        } else { 
            Err(self.error(UnexpectedToken { 
                found: self.current.clone(),
                expected: kind 
            }))
        }
    }
}
```

**å…³é”®è®¾è®¡**ï¼šParser ä¸ç›´æ¥ä¾èµ–å…·ä½“ Lexer å®ç°ï¼Œåªä¾èµ– `TokenStream` traitã€‚è¿™ä½¿å¾—ï¼š
- å¯ä»¥åŒæ—¶æ”¯æŒæµå¼ Lexer å’Œæ‰¹é‡ Lexer
- æµ‹è¯•æ—¶å¯ä»¥æ³¨å…¥ Mock Token åºåˆ—
- æœªæ¥æ”¯æŒå¢é‡è§£ææ—¶ï¼ŒLexer å¯ä»¥ç‹¬ç«‹æ¼”è¿›

#### 5.2.3 DSL è§£æç­–ç•¥

å¯¹äº `json { ... }` å’Œæœªæ¥çš„ DSLï¼ŒParser é‡‡ç”¨**å§”æ‰˜æ¨¡å¼**ï¼š

```rust
fn parse_primary(&mut self) -> ParseResult<Expr> {
    match self.current_kind() {
        // ... åŸºç¡€ç±»å‹
        TokenKind::Json => self.parse_json_literal(),
        TokenKind::Xml => self.parse_xml_literal(),
        // ...
    }
}

fn parse_json_literal(&mut self) -> ParseResult<Expr> {
    self.consume(); // æ¶ˆè´¹ 'json'
    self.expect(TokenKind::LeftCurlyBrace)?;
    
    // åœ¨ { ... } å†…ä½¿ç”¨ JSON ä¸“ç”¨è§£æé€»è¾‘
    // å¯ä»¥å¤ç”¨ Parser çš„åŸºç¡€è®¾æ–½ï¼Œä½†è¯­æ³•è§„åˆ™ä¸åŒ
    let entries = self.parse_json_entries()?;
    
    self.expect(TokenKind::RightCurlyBrace)?;
    Ok(Expr::JsonLiteral(entries))
}
```

#### 5.2.4 å¢é‡è§£ææ”¯æŒ

Parser ä» Lexer æ¥æ”¶**å¢é‡æ›´æ–°**ï¼š

```rust
pub struct IncrementalParser {
    lexer: IncrementalLexer,
    ast_cache: HashMap<Range<usize>, AstNode>,
}

impl IncrementalParser {
    /// ç¼–è¾‘åå±€éƒ¨é‡è§£æ
    pub fn on_edit(&mut self, edit: TextEdit) -> ParseResult<Module> {
        // 1. é€šçŸ¥ Lexer æ›´æ–°
        let token_changes = self.lexer.on_edit(edit);
        
        // 2. æ‰¾åˆ°å—å½±å“çš„ AST èŠ‚ç‚¹
        let affected = self.find_affected_nodes(&token_changes);
        
        // 3. é‡æ–°è§£æå—å½±å“çš„è¯­å¥/å£°æ˜
        for node in affected {
            self.reparse_node(node)?;
        }
        
        // 4. å¦‚æœç»“æ„å˜åŒ–ï¼ˆå¦‚æ‹¬å·ä¸åŒ¹é…ï¼‰ï¼Œæ‰©å¤§é‡è§£æèŒƒå›´
        Ok(self.module.clone())
    }
}
```

#### 5.2.5 å…³é”®æ—¥å¿—ç‚¹

| çº§åˆ« | ç›®æ ‡ | å†…å®¹ |
|------|------|------|
| `TRACE` | `kaubo::parser::token` | Token æ¶ˆè´¹è¯¦æƒ… |
| `DEBUG` | `kaubo::parser::rule` | è§„åˆ™è¿›å…¥/é€€å‡ºï¼ˆspanï¼‰ |
| `DEBUG` | `kaubo::parser::ast` | AST èŠ‚ç‚¹ç”Ÿæˆ |
| `INFO` | `kaubo::parser` | è§£æå¼€å§‹/å®Œæˆ |

### 5.3 å­—èŠ‚ç ç¼–è¯‘å™¨ (AST â†’ Bytecode)

**ä½ç½®**: `src/runtime/compiler.rs`  
**æ—¥å¿—ç›®æ ‡**: `kaubo::compiler`

#### 5.3.1 èŒè´£

Compiler è´Ÿè´£å°† Parser ç”Ÿæˆçš„ AST ç¼–è¯‘ä¸º VM å¯æ‰§è¡Œçš„å­—èŠ‚ç ï¼š

```
AST â”€â”€â–º Compiler â”€â”€â–º Chunk (Bytecode + Constants)
```

#### 5.3.2 å…³é”®æ—¥å¿—ç‚¹

| çº§åˆ« | ç›®æ ‡ | å†…å®¹ |
|------|------|------|
| `TRACE` | `kaubo::compiler::op` | æŒ‡ä»¤ç”Ÿæˆè¯¦æƒ… |
| `DEBUG` | `kaubo::compiler::var` | å˜é‡è§£æã€ä½œç”¨åŸŸ |
| `DEBUG` | `kaubo::compiler::shape` | ShapeID åˆ†é… |
| `INFO` | `kaubo::compiler` | ç¼–è¯‘å•å…ƒå®Œæˆ |

### 5.4 è™šæ‹Ÿæœº (VM)

**ä½ç½®**: `src/runtime/vm.rs`

**æ—¥å¿—ç›®æ ‡**: `kaubo::vm`

**å…³é”®æ—¥å¿—ç‚¹**:
- æŒ‡ä»¤æ‰§è¡Œ (`TRACE`)
- å‡½æ•°è°ƒç”¨ (`DEBUG`)
- æ ˆæ“ä½œ (`TRACE`)

---

## 6. å†…å­˜å¸ƒå±€

### 6.1 Value ç±»å‹ (NaN Boxing)

```
[63] Sign [62-52] Exponent(0x7FF) [51] QNAN [50-44] Tag [43-0] Payload

æ ‡ç­¾åˆ†é…:
  0-7   : ç‰¹æ®Šå€¼ (null, true, false, SMI)
  8-23  : å†…è”æ•´æ•° (-8 ~ +7)
  32    : å †å¯¹è±¡ (Boxed)
  33    : å­—ç¬¦ä¸²
  34    : å‡½æ•°
  35    : åˆ—è¡¨
  37    : é—­åŒ…
  38    : åç¨‹
  42    : æ¨¡å—
  43    : åŸç”Ÿå‡½æ•°
```

### 6.2 æ¨¡å— ShapeID

```rust
// ç¼–è¯‘æœŸç¡®å®š
"std" æ¨¡å—:
  "print"     -> ShapeID 0
  "assert"    -> ShapeID 1
  "type"      -> ShapeID 2
  "sqrt"      -> ShapeID 4
  "PI"        -> ShapeID 9

// è¿è¡Œæ—¶è®¿é—®
ModuleGet 0   // O(1) ç›´æ¥ç´¢å¼•
```

---

## 7. æ–‡ä»¶ç»“æ„

```
src/
â”œâ”€â”€ lib.rs              # åº“å…¥å£ï¼šå¯¼å‡ºå…¬å…± API
â”œâ”€â”€ main.rs             # CLI å…¥å£ï¼šå‚æ•°è§£æã€æµç¨‹è°ƒåº¦
â”œâ”€â”€ api.rs              # ã€æ–°å¢ã€‘é«˜å±‚ API (compile, run ç­‰)
â”œâ”€â”€ config.rs           # ã€æ–°å¢ã€‘å…¨å±€é…ç½®
â”œâ”€â”€ logger.rs           # ã€æ–°å¢ã€‘æ—¥å¿—åˆå§‹åŒ–
â”‚
â”œâ”€â”€ compiler/           # ç¼–è¯‘å™¨å‰ç«¯
â”‚   â”œâ”€â”€ lexer/
â”‚   â”‚   â”œâ”€â”€ builder.rs
â”‚   â”‚   â”œâ”€â”€ token_kind.rs
â”‚   â”‚   â””â”€â”€ logging.rs  # ã€æ–°å¢ã€‘Lexer æ—¥å¿—å·¥å…·
â”‚   â””â”€â”€ parser/
â”‚       â”œâ”€â”€ parser.rs
â”‚       â”œâ”€â”€ expr.rs
â”‚       â”œâ”€â”€ stmt.rs
â”‚       â””â”€â”€ logging.rs  # ã€æ–°å¢ã€‘Parser æ—¥å¿—å·¥å…·
â”‚
â”œâ”€â”€ runtime/            # è¿è¡Œæ—¶
â”‚   â”œâ”€â”€ bytecode/
â”‚   â”œâ”€â”€ stdlib/
â”‚   â”œâ”€â”€ vm.rs
â”‚   â”œâ”€â”€ vm/
â”‚   â”‚   â””â”€â”€ logging.rs  # ã€æ–°å¢ã€‘VM æ—¥å¿—å·¥å…·
â”‚   â”œâ”€â”€ compiler.rs
â”‚   â”œâ”€â”€ object.rs
â”‚   â””â”€â”€ value.rs
â”‚
â””â”€â”€ kit/                # å·¥å…·åº“

tests/
â”œâ”€â”€ api_tests.rs        # ã€æ–°å¢ã€‘API å±‚æµ‹è¯•
â”œâ”€â”€ lexer_tests.rs      # ã€æ–°å¢ã€‘Lexer ç‹¬ç«‹æµ‹è¯•
â”œâ”€â”€ parser_tests.rs     # ã€æ–°å¢ã€‘Parser ç‹¬ç«‹æµ‹è¯•
â”œâ”€â”€ compiler_tests.rs   # ã€æ–°å¢ã€‘Compiler ç‹¬ç«‹æµ‹è¯•
â”œâ”€â”€ vm_tests.rs         # VM æ‰§è¡Œæµ‹è¯•
â”œâ”€â”€ stdlib_tests.rs     # æ ‡å‡†åº“æµ‹è¯•
â””â”€â”€ common/
    â””â”€â”€ mod.rs          # æµ‹è¯•å…±äº«å·¥å…·
```

---

## 8. æœªæ¥åŠŸèƒ½æ‰©å±•è·¯å¾„

åŸºäºæ–°çš„ Lexer-Parser æ¶æ„ï¼Œä»¥ä¸‹åŠŸèƒ½å¯ä»¥**é€æ­¥æ·»åŠ **ï¼š

### 8.1 è¯­æ³•é«˜äº® (TreeSitter)

```rust
// ä¸º TreeSitter æä¾›å¤–éƒ¨ scanner
#[no_mangle]
pub extern "C" fn tree_sitter_kaubo_external_scaner_scan(...) -> bool {
    // å¤ç”¨ KauboScanner
}
```

**äº¤ä»˜ç‰©**ï¼šVS Codeã€Neovimã€Sublime çš„è¯­æ³•é«˜äº®æ’ä»¶  
**ä¾èµ–**ï¼šPhase 0 å®Œæˆ  
**å·¥ä½œé‡**ï¼š2-3 å¤©

### 8.2 Language Server (LSP)

```rust
pub struct KauboLanguageServer {
    lexer: IncrementalLexer,      // å¢é‡è¯æ³•åˆ†æ
    parser: IncrementalParser,    // å¢é‡è¯­æ³•åˆ†æ
    symbols: SymbolTable,         // ç¬¦å·è¡¨
    types: TypeChecker,           // ç±»å‹æ£€æŸ¥ï¼ˆæœªæ¥ï¼‰
}

impl LanguageServer for KauboLanguageServer {
    fn on_change(&mut self, changes: &[TextEdit]) {
        // 1. å¢é‡è¯æ³•åˆ†æ
        let errors = self.lexer.on_edit(changes);
        
        // 2. å¢é‡è¯­æ³•åˆ†æ
        let ast = self.parser.incremental_parse(&self.lexer);
        
        // 3. æ›´æ–°è¯Šæ–­ä¿¡æ¯
        self.publish_diagnostics(errors);
    }
    
    fn goto_definition(&self, pos: Position) -> Option<Location> {
        self.symbols.find_definition(pos)
    }
    
    fn completion(&self, pos: Position) -> Vec<CompletionItem> {
        self.get_completion_context(pos).suggest()
    }
}
```

**åŠŸèƒ½æ¸…å•**ï¼š

| åŠŸèƒ½ | ä¾èµ– | å·¥ä½œé‡ | ä¼˜å…ˆçº§ |
|------|------|--------|--------|
| è¯­æ³•é”™è¯¯è¯Šæ–­ | Phase 1 é”™è¯¯ç³»ç»Ÿ | 1å¤© | P0 |
| å®æ—¶é”™è¯¯æç¤º | Phase 2 å¢é‡è§£æ | 2å¤© | P0 |
| è·³è½¬åˆ°å®šä¹‰ | Symbol Table | 3å¤© | P1 |
| è‡ªåŠ¨è¡¥å…¨ | Scope Analysis | 3å¤© | P1 |
| æ‚¬åœæç¤º | Type System | 5å¤© | P2 |
| é‡å‘½å | å¼•ç”¨åˆ†æ | 5å¤© | P2 |
| ä»£ç æ ¼å¼åŒ– | AST Printer | 3å¤© | P2 |

### 8.3 å®æ—¶ REPL

```rust
pub struct KauboRepl {
    lexer: IncrementalLexer,
    parser: IncrementalParser,
    vm: Vm,
}

impl KauboRepl {
    pub fn run_line(&mut self, input: &str) -> Result<Value, ReplError> {
        match self.parser.try_parse_statement(&mut self.lexer) {
            ParseStatus::Complete(stmt) => {
                let chunk = compile(&stmt)?;
                Ok(self.vm.execute(&chunk)?)
            }
            ParseStatus::Incomplete => {
                // æç¤ºç”¨æˆ·ç»§ç»­è¾“å…¥ï¼ˆ...ï¼‰
                Err(ReplError::NeedMoreInput)
            }
            ParseStatus::Error(e) => Err(e.into()),
        }
    }
}
```

**æ•ˆæœ**ï¼š
```text
kaubo> var x = 1
...    +
...    2
...    ;              // æ£€æµ‹åˆ°å®Œæ•´ statementï¼Œæ‰§è¡Œ
=> 3

kaubo> var f = |x| {  // å¤šè¡Œ lambda è‡ªç„¶æ”¯æŒ
...    return x * 2;
...    };
=> <function>
```

### 8.4 å¤š DSL æ”¯æŒ

åŸºäºç»Ÿä¸€çš„ Scanner æ¶æ„ï¼Œæ–° DSL çš„å®ç°æˆæœ¬ï¼š

| DSL | ä»£ç é‡ | å¤ç”¨ç‡ | å…³é”®ç‰¹æ€§ |
|-----|--------|--------|----------|
| JSON | ~80è¡Œ | 80% | å¤ç”¨ core scanner |
| Vue æ¨¡æ¿ | ~200è¡Œ | 70% | æ¨¡å¼åˆ‡æ¢ç³»ç»Ÿ |
| SQL | ~100è¡Œ | 85% | å…³é”®å­— + å­—ç¬¦ä¸² |
| Markdown | ~150è¡Œ | 75% | è¡Œçº§è§£æ |

---

## 9. å…³é”®è®¾è®¡å†³ç­–

### 9.1 é€šç”¨å†³ç­–

| å†³ç­– | æ–¹æ¡ˆ | åŸå›  |
|------|------|------|
| æ—¥å¿—æ¡†æ¶ | `tracing` | ç»“æ„åŒ–ã€å¼‚æ­¥ã€æ”¯æŒ span |
| CLI æ¡†æ¶ | `clap` | å£°æ˜å¼ã€åŠŸèƒ½å…¨ã€æ–‡æ¡£å¥½ |
| å…¨å±€é…ç½® | `once_cell` | çº¿ç¨‹å®‰å…¨ã€å»¶è¿Ÿåˆå§‹åŒ– |
| é”™è¯¯å¤„ç† | `thiserror` | ç±»å‹å®‰å…¨ã€è‡ªåŠ¨å®ç° Error |
| é…ç½®ä¼ é€’ | å•ä¾‹æ¨¡å¼ | é¿å…å±‚å±‚ä¼ é€’å‚æ•° |
| æ—¥å¿—çº§åˆ« | åˆ†é˜¶æ®µç‹¬ç«‹æ§åˆ¶ | ä¾¿äºè°ƒè¯•ç‰¹å®šé˜¶æ®µé—®é¢˜ |

### 9.2 Lexer æ”¹é€ å†³ç­–

| å†³ç­– | æ–¹æ¡ˆ | åŸå›  |
|------|------|------|
| æ ¸å¿ƒç®—æ³• | æ‰‹å†™ç›´æ¥æ‰«æ | O(n) å¤æ‚åº¦ï¼Œç¼“å­˜å‹å¥½ï¼Œæ˜“äºæ‰©å±• |
| æ¶æ„æ¨¡å¼ | ä¸‰å±‚æ¶æ„ (Infra-Core-DSL) | åŸºç¡€è®¾æ–½å¤ç”¨ï¼ŒDSL å¿«é€Ÿè¿­ä»£ |
| è¯­æ³•å®šä¹‰ | å£°æ˜å¼å® (`lexer_definition!`) | æ”¹è¯­æ³•åªéœ€æ”¹é…ç½®ï¼Œç¼–è¯‘æ—¶ä¼˜åŒ– |
| åæ ‡ç³»ç»Ÿ | UTF-8 + UTF-16 åŒåæ ‡ | æ”¯æŒ LSP åè®®ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ |
| é”™è¯¯æ¢å¤ | Panic Mode | ç®€å•æœ‰æ•ˆï¼Œä¸šç•Œæ ‡å‡† |
| æµå¼æ”¯æŒ | `StreamResult<T>` | é˜»å¡/éé˜»å¡ç»Ÿä¸€æ¥å£ |
| å¢é‡è§£æ | Token ç¼“å­˜ + èŒƒå›´æ£€æµ‹ | IDE å®æ—¶åé¦ˆåŸºç¡€ |

### 9.3 Parser åä½œå†³ç­–

| å†³ç­– | æ–¹æ¡ˆ | åŸå›  |
|------|------|------|
| è§£æç®—æ³• | é€’å½’ä¸‹é™ + Pratt | è¡¨è¾¾åŠ›å¼ºï¼Œå·¦é€’å½’å®‰å…¨ï¼Œæ˜“äºç»´æŠ¤ |
| æ¥å£è®¾è®¡ | `TokenStream` trait | Lexer/Parser è§£è€¦ï¼Œæ”¯æŒå¤šç§è¾“å…¥æº |
| DSL æ”¯æŒ | Parser ä¸»å¯¼ + Lexer è¾…åŠ© | JSON/æ¨¡æ¿ç­‰å¤æ‚ç»“æ„åœ¨ Parser å±‚å¤„ç† |
| å¢é‡æ”¯æŒ | åŸºäº Lexer å¢é‡æ›´æ–° | Parser å¤ç”¨ Lexer çš„å±€éƒ¨é‡è§£æèƒ½åŠ› |

---

## 10. å®æ–½è·¯çº¿å›¾

```
Phase 0: åŸºç¡€é‡æ„ (2å‘¨)
â”œâ”€â”€ CharStream + Position ç³»ç»Ÿ
â”œâ”€â”€ KauboScanner æ‰‹å†™å®ç°
â”œâ”€â”€ API å…¼å®¹å±‚
â””â”€â”€ æ€§èƒ½åŸºå‡†æµ‹è¯•

Phase 1: é”™è¯¯ç³»ç»Ÿ (1å‘¨)
â”œâ”€â”€ ç»Ÿä¸€ LexError ç±»å‹
â”œâ”€â”€ SourceSpan ç²¾å‡†å®šä½
â”œâ”€â”€ ç¾è§‚é”™è¯¯æ¸²æŸ“
â””â”€â”€ é”™è¯¯æ¢å¤ç­–ç•¥

Phase 2: å¢é‡è§£æ (2å‘¨)
â”œâ”€â”€ IncrementalLexer
â”œâ”€â”€ Token ç¼“å­˜ç³»ç»Ÿ
â”œâ”€â”€ on_edit å±€éƒ¨é‡è§£æ
â””â”€â”€ LSP ä½ç½®æ˜ å°„

Phase 3: DSL ç”Ÿæ€ (2å‘¨)
â”œâ”€â”€ JsonScanner
â”œâ”€â”€ VueScanner (æ¨¡å¼åˆ‡æ¢æ¼”ç¤º)
â”œâ”€â”€ å£°æ˜å¼è¯­æ³•å®šä¹‰å®
â””â”€â”€ DSL å¼€å‘æ–‡æ¡£

Phase 4+: IDE é›†æˆ (æŒ‰éœ€)
â”œâ”€â”€ TreeSitter ç»‘å®š
â”œâ”€â”€ LSP Server
â”œâ”€â”€ REPL å¢å¼º
â””â”€â”€ åœ¨çº¿ Playground
```

---

*æœ€åæ›´æ–°: 2026-02-11*  
*ç‰ˆæœ¬: 3.1 (Lexer æ¶æ„å‡çº§æ–¹æ¡ˆ)*
