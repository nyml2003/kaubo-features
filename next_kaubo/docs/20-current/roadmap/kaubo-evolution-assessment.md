# Kaubo 演进方案评估报告

> 评估改造后的语言特性与设计目标的符合度

---

## 1. Kaubo 设计目标回顾

根据已有文档，Kaubo 的核心定位：

| 目标 | 描述 | 优先级 |
|------|------|--------|
| **脚本语言** | 易用、快速开发、适合嵌入式/配置场景 | P0 |
| **严格类型** | 编译期类型检查，无隐式转换 | P0 |
| **高性能** | 字节码 + 优化（内联缓存、单态化） | P1 |
| **跨平台** | Windows/Mac/Linux/Web(WASM) | P1 |
| **模块化** | 代码组织、标准库可扩展 | P2 |
| **简洁实现** | 代码量可控，易于维护 | P2 |

---

## 2. 改造后特性评估

### 2.1 泛型系统 - ⚠️ 权衡

**设计**：
- `[T]` 泛型参数语法
- 单态化（基本类型）+ 类型擦除（堆类型）
- Hindley-Milner 类型推导

**与设计目标的符合度**：

| 目标 | 评估 | 说明 |
|------|------|------|
| 严格类型 | ✅ **增强** | 泛型让 List[int] vs List[string] 有明确区分 |
| 高性能 | ✅ **支持** | 基本类型单态化零开销 |
| 脚本语言 | ⚠️ **妥协** | 增加了学习曲线，复杂度接近 Rust/TS |
| 简洁实现 | ❌ **冲突** | 约 1500 行复杂代码（约束求解、单态化） |

**风险**：
- 泛型让 Kaubo 从"简单脚本语言"变成"系统脚本语言"
- 维护成本显著增加（类型推导 bug、单态化膨胀）

**建议**：
```
如果目标保持"简单脚本语言"：
  → 泛型可以简化，只支持 List[T]/Box[T] 等内置泛型
  → 不支持用户自定义泛型 struct/impl
  → 工作量从 6周 → 2周

如果目标是"带脚本的系统语言"：
  → 当前设计合理
```

---

## 3. 模块系统改造 - ✅ 符合

**设计**：
- 单文件单模块（删除 `module` 关键字）
- VFS 跨平台抽象
- 基于文件路径的 import

**评估**：

| 目标 | 评估 | 说明 |
|------|------|------|
| 脚本语言 | ✅ **改善** | 文件即模块，概念更简单 |
| 跨平台 | ✅ **支持** | VFS 支持 Web/WASM |
| 模块化 | ✅ **增强** | 清晰的文件组织 |
| 简洁实现 | ✅ **合理** | VFS 约 400 行，值得投入 |

**结论**：此改造强烈推荐实施。

---

## 4. 插件化 Std - ✅ 符合

**设计**：
- `kaubo-std` 独立 crate
- 通过 trait + 宏自动包装
- 零编译器依赖

**评估**：

| 目标 | 评估 | 说明 |
|------|------|------|
| 模块化 | ✅ **符合** | 标准库可独立更新 |
| 跨平台 | ✅ **支持** | 平台相关代码隔离在 std 中 |
| 简洁实现 | ✅ **改善** | 编译器不再硬编码 722 行 std |
| 高性能 | ⚠️ **微小开销** | 函数指针调用 vs 直接调用 |

**风险与缓解**：
- **风险**：trait object 动态调用有轻微开销
- **缓解**：热点函数可在编译器内联，或提供 `#[inline]` 标记

**结论**：值得实施，提升架构质量。

---

## 5. 类型推断增强 - ✅ 符合

**设计**：
- 链式调用 `.filter().map()` 类型推导
- 上下文敏感推导

**评估**：

| 目标 | 评估 | 说明 |
|------|------|------|
| 脚本语言 | ✅ **改善** | 减少类型标注，提升开发体验 |
| 严格类型 | ✅ **不冲突** | 推导失败可回退到显式标注 |
| 简洁实现 | ⚠️ **中等复杂度** | unify 算法约 300 行 |

**与匿名函数的兼容性**：

```kaubo
// 由于只支持匿名函数，类型推导需要特殊处理
var identity = |[T] x: T| -> T { return x; };
identity(42)  // 推导 T=int，可行

// 但无法推导 lambda 参数类型（无上下文时）
nums.map(|x| -> int { return x * 2; })  // 必须标注返回类型
```

**结论**：合理投入，提升用户体验。

---

## 6. 综合评估矩阵

| 特性 | 严格类型 | 脚本易用 | 高性能 | 跨平台 | 简洁实现 | 综合 |
|------|----------|----------|--------|--------|----------|------|
| **泛型系统** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 权衡 |
| **模块改造** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 推荐 |
| **插件化 Std** | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 推荐 |
| **类型推断** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | 推荐 |

---

## 7. 核心问题：脚本语言需要泛型吗？

### 7.1 正反论证

**支持泛型的论点**：
- TypeScript/Python 都有泛型/类型参数，市场接受
- `List[any]` 确实丢失类型信息，影响安全性
- 现代脚本语言趋势是"渐进式类型"

**反对泛型的论点**：
- Lua/JavaScript 没有泛型也很成功
- 脚本语言的价值在于快速开发，而非类型完美
- 20周投入 vs 收益比需要斟酌

### 7.2 折中方案建议

如果担心泛型过度设计，可采用**简化版泛型**：

```kaubo
// 方案 A：仅内置泛型（推荐简化版）
// 只支持 List[T], Box[T] 等内置类型
// 不支持用户自定义泛型 struct
// 不支持泛型 lambda
// 工作量：2周

// 方案 B：有限泛型（当前设计）
// 支持自定义泛型 struct/impl
// 支持泛型 lambda
// 完整类型推导
// 工作量：6周

// 方案 C：无泛型（最简）
// 保持 List[any]
// 通过文档约定类型
// 工作量：0周
```

**推荐**：如果团队资源有限，先实施方案 A（仅内置泛型），后续根据需求升级。

---

## 8. 改造后 Kaubo 定位

### 8.1 语言类型对比

| 语言 | 类型系统 | 泛型 | 与改造后 Kaubo 对比 |
|------|----------|------|---------------------|
| **Lua** | 动态 | 无 | Kaubo 更严格，适合大型脚本 |
| **Python** | 动态 + 类型提示 | 有（typing）| Kaubo 编译期检查更严格 |
| **TypeScript** | 渐进静态 | 有 | 类似，但 Kaubo 无 JS 包袱 |
| **Rust** | 严格静态 | 完整 | Kaubo 更简单，无所有权 |
| **Go** | 静态 | 有限（interface）| Kaubo 有泛型，Go 没有 |

**改造后定位**：
> "带严格类型和泛型的轻量级脚本语言，适合游戏脚本、配置文件、嵌入式逻辑"

### 8.2 适用场景

| 场景 | 适合度 | 说明 |
|------|--------|------|
| 游戏脚本 | ⭐⭐⭐⭐⭐ | 泛型容器 + 协程完美契合 |
| 配置文件 | ⭐⭐⭐⭐ | 类型安全优于 JSON/YAML |
| Web 后端 | ⭐⭐⭐ | 性能足够，生态不如 Node |
| 系统编程 | ⭐⭐ | 不如 Rust/C++，但够用 |
| 教学语言 | ⭐⭐ | 泛型增加学习门槛 |

---

## 9. 实施建议

### 9.1 分阶段实施（保守策略）

```
第一阶段（4周）：必做
├── 模块系统改造（单文件单模块）
├── VFS（虚拟文件系统）
└── 插件化 Std（核心函数）

第二阶段（2周）：观望
├── 内置泛型（仅 List[T], Box[T]）
└── 基础类型推导

第三阶段（根据反馈）：可选
├── 用户自定义泛型
├── 完整类型推导
└── 高级泛型特性
```

### 9.2 决策树

```
团队资源充足（5个月）？
├── 是 → 按完整路线图实施
└── 否 → 只需要基础脚本能力？
    ├── 是 → 只做模块改造 + 插件化 Std（6周）
    └── 否 → 做第一阶段 + 内置泛型（6周）
```

---

## 10. 结论

### 10.1 总体评估

| 维度 | 评分 | 说明 |
|------|------|------|
| **符合设计目标** | 7/10 | 大部分符合，泛型有过度设计风险 |
| **技术可行性** | 9/10 | 技术路线清晰，风险可控 |
| **投入产出比** | 6/10 | 20周投入较大，需权衡 |
| **架构质量提升** | 9/10 | 模块化和插件化显著改善架构 |

### 10.2 关键建议

1. **模块系统改造（Phase 1）**：✅ **强烈推荐**
   - 收益明显，风险低，符合脚本语言定位

2. **插件化 Std（Phase 4）**：✅ **推荐**
   - 架构改善，长期维护成本降低

3. **泛型系统（Phase 2）**：⚠️ **建议简化**
   - 如果资源有限，只做"内置泛型"
   - 避免 Hindley-Milner 的复杂度
   - 后续根据实际需求再扩展

4. **类型推断（Phase 3）**：✅ **推荐基础版**
   - 不需要完整的 HM 算法
   - 仅支持常用场景（成员访问、简单链式）

### 10.3 最小可行演进（推荐）

```
6周版本（保守但实用）：
├── 模块系统改造（单文件单模块）
├── VFS
├── 插件化 Std（核心函数）
└── 内置泛型（List[T] 等，无用户泛型）

语言定位：
"有严格类型和基础泛型的简洁脚本语言"
```

**这样既保持了 Kaubo 的简洁性，又获得了泛型的主要收益。**

---

*评估版本：1.0 | 日期：2026-02-16*
