# 当前架构（v2025.02）

> ⚠️ 此文件随时可能重写。这是当前实验状态，不是承诺。

## 目标架构方向

```
源代码 (.kaubo)
      ↓
[流式Lexer] → Tokens
      ↓
[增量Parser] → AST
      ↓
[类型检查器] → Typed AST
      ↓
      ├─→ [解释器] → 立即执行（冷代码/调试）
      └─→ [JIT编译器] → 机器码 → 热点执行
                    ↓
              [热重载层] ← 状态序列化/恢复
```

## 关键设计决策（待定）

### 1. JIT后端选择

**候选**：Cranelift vs LLVM ORC

**评估维度**：
| 维度 | Cranelift | LLVM |
|------|-----------|------|
| 编译速度 | ✅ 快 | ❌ 慢 |
| 生成代码质量 | ⚠️ 一般 | ✅ 优秀 |
| 依赖复杂度 | ✅ 低 | ❌ 高 |
| Rust生态支持 | ✅ 原生 | ⚠️ 需bindgen |

**当前倾向**：Cranelift（满足performance-limits.md的<100ms约束）

**验证假设**：Cranelift生成的代码足够快（目标>5倍解释器）

### 2. 热重载粒度

**选项**：
- A) 函数级（替换单个函数）
- B) 模块级（替换整个文件）

**当前倾向**：A，与JIT函数级编译对齐

**挑战**：正在执行的函数如何安全替换？

### 3. 状态保持机制

**选项**：
- A) 全局状态快照（序列化所有全局变量）
- B) 标记保留函数（@hot标记的函数保持栈帧）
- C) 用户显式迁移函数

**当前倾向**：B+A混合，@hot函数自动保留，全局变量可选序列化

## 组件边界（暂定）

```
kaubo-core/
├── lexer/          # 流式Lexer，支持断点续传
├── parser/         # 增量Parser，函数级粒度
├── typer/          # 类型检查器，生成Typed AST
├── interpreter/    # 字节码解释器（保底）
├── jit/            # JIT编译器（Cranelift）
│   └── ic.rs       # 内联缓存（利用Shape系统）
└── hotreload/      # 热重载协调
    ├── state.rs    # 状态序列化
    └── patch.rs    # 代码替换
```

## 关键技术风险

| 风险 | 影响 | 缓解方案 |
|------|------|---------|
| Cranelift编译时间>100ms | P0约束违反 | 降级到解释器+后台编译 |
| 热重载状态恢复失败 | 用户体验差 | 提供"冷启动"回退 |
| Shape系统与JIT冲突 | 架构重写 | 预留抽象层 |

## 实验记录

- 2025-02-14: 初始架构设计，基于Kaubo现有代码分析

---

*此文件是工作区，不代表最终设计*
